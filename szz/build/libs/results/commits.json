{"549ef0e052bba6e0ffdfad9f891f0ee68e0b7c7c":{"changes":{"src\/cmd_context\/cmd_context.cpp":"MODIFY","src\/cmd_context\/basic_cmds.cpp":"MODIFY"},"diff":{"src\/cmd_context\/cmd_context.cpp":[{"add":["936","            throw cmd_exception(\"ambiguous function declaration reference, provide full signature to disambiguate (<symbol> (<sort>*) <sort>) \", s);"],"delete":["936","            throw cmd_exception(\"ambiguous function declaration reference, provide full signature to disumbiguate (<symbol> (<sort>*) <sort>) \", s);"]}],"src\/cmd_context\/basic_cmds.cpp":[{"add":["769","    char const * get_descr(cmd_context & ctx) const override { return \"declare a new array map operator with name <symbol> using the given function declaration.\\n<func-decl-ref> ::= <symbol>\\n                  | (<symbol> (<sort>*) <sort>)\\n                  | ((_ <symbol> <numeral>+) (<sort>*) <sort>)\\nThe last two cases are used to disambiguate between declarations with the same name and\/or select (indexed) builtin declarations.\\nFor more details about the array map operator, see 'Generalized and Efficient Array Decision Procedures' (FMCAD 2009).\\nExample: (declare-map set-union (Int) (or (Bool Bool) Bool))\\nDeclares a new function (declare-fun set-union ((Array Int Bool) (Array Int Bool)) (Array Int Bool)).\\nThe instance of the map axiom for this new declaration is:\\n(forall ((a1 (Array Int Bool)) (a2 (Array Int Bool)) (i Int)) (= (select (set-union a1 a2) i) (or (select a1 i) (select a2 i))))\"; }"],"delete":["769","    char const * get_descr(cmd_context & ctx) const override { return \"declare a new array map operator with name <symbol> using the given function declaration.\\n<func-decl-ref> ::= <symbol>\\n                  | (<symbol> (<sort>*) <sort>)\\n                  | ((_ <symbol> <numeral>+) (<sort>*) <sort>)\\nThe last two cases are used to disumbiguate between declarations with the same name and\/or select (indexed) builtin declarations.\\nFor more details about the array map operator, see 'Generalized and Efficient Array Decision Procedures' (FMCAD 2009).\\nExample: (declare-map set-union (Int) (or (Bool Bool) Bool))\\nDeclares a new function (declare-fun set-union ((Array Int Bool) (Array Int Bool)) (Array Int Bool)).\\nThe instance of the map axiom for this new declaration is:\\n(forall ((a1 (Array Int Bool)) (a2 (Array Int Bool)) (i Int)) (= (select (set-union a1 a2) i) (or (select a1 i) (select a2 i))))\"; }"]}]}},"3024fe7baf712241d79f3fb1724c68c2402a2c4e":{"changes":{"src\/smt\/smt_model_generator.cpp":"MODIFY"},"diff":{"src\/smt\/smt_model_generator.cpp":[{"add":["295","        scoped_reset _scoped_reset(*this, procs);"],"delete":["317","        scoped_reset _scoped_reset(*this, procs);"]}]}},"7f8a7c3d83011dd1d0571b2c4d954b3434f60901":{"changes":{"src\/test\/main.cpp":"MODIFY"},"diff":{"src\/test\/main.cpp":[{"add":["12","","210","    if (test_all) return 0;"],"delete":["12","static void tst_exit_all_tests() {","13","    exit(0);","14","}","212","    TST(exit_all_tests);"]}]}},"dbdb0307dbd4d84920719e47abb1bd13b403154a":{"changes":{"scripts\/update_api.py":"MODIFY"},"diff":{"scripts\/update_api.py":[{"add":["712","","713","            elif k == IN and param_type(param) == STRING:","714","                java_wrapper.write('  jenv->ReleaseStringUTFChars(a%s, _a%s);\\n' % (i, i));"],"delete":[]}]}},"0a97f37be504331354b1db322d75507e125612a5":{"changes":{"src\/model\/model.cpp":"MODIFY"},"diff":{"src\/model\/model.cpp":[{"add":["145","    sort2universe::obj_map_entry * entry = m_usort2universe.insert_if_not_there2(s, nullptr);","147","    ptr_vector<expr> * u = entry->get_data().m_value;","148","    if (!u) {","151","        u = alloc(ptr_vector<expr>);","152","        u->append(usize, universe);","153","        entry->get_data().m_value = u;","157","        u->reset();"],"delete":["145","    sort2universe::obj_map_entry * entry = m_usort2universe.insert_if_not_there2(s, 0);","147","    if (entry->get_data().m_value == 0) {","148","        \/\/ new entry","151","        ptr_vector<expr> * new_u = alloc(ptr_vector<expr>);","152","        new_u->append(usize, universe);","153","        entry->get_data().m_value = new_u;","156","        \/\/ updating","157","        ptr_vector<expr> * u = entry->get_data().m_value;","158","        SASSERT(u);"]}]}},"b402268d3532debf140253190b39b4dce4eaf9d0":{"changes":{"src\/ast\/rewriter\/seq_rewriter.cpp":"MODIFY","src\/smt\/theory_seq.h":"MODIFY","src\/smt\/seq_eq_solver.cpp":"MODIFY"},"diff":{"src\/ast\/rewriter\/seq_rewriter.cpp":[{"add":["1385","    expr* a2, *i2;","1386","    if (len == 0 && str().is_at(a, a2, i2) && m_autil.is_numeral(i2, r) && r.is_zero()) {","1387","        result = str().mk_nth_i(a2, i2);","1388","        return BR_REWRITE1;","1389","    }","1390",""],"delete":[]}],"src\/smt\/theory_seq.h":[{"add":["461","        obj_pair_hashtable<expr, expr> m_nth_eq2_cache;"],"delete":[]}],"src\/smt\/seq_eq_solver.cpp":[{"add":["1579","struct remove_obj_pair_map : public trail<context> {","1580","    obj_pair_hashtable<expr, expr> & m_map;","1581","    expr* a, *b;","1582","    remove_obj_pair_map(obj_pair_hashtable<expr, expr> & map, expr* a, expr* b):","1583","        m_map(map), a(a), b(b) {}","1584","    void undo(context& ctx) override {","1585","        m_map.erase(std::make_pair(a, b));","1586","    }","1587","};","1588","","1603","        if (m_nth_eq2_cache.contains(std::make_pair(rhs, ls[0])))","1604","            return false;","1605","        m_nth_eq2_cache.insert(std::make_pair(rhs, ls[0]));","1606","        ctx.push_trail(remove_obj_pair_map(m_nth_eq2_cache, rhs, ls[0]));"],"delete":[]}]}},"40aa2f7cb294d6ab8afb8aede0e28d06962df190":{"changes":{"src\/ast\/ast.cpp":"MODIFY","src\/muz\/base\/hnf.cpp":"MODIFY","src\/muz\/fp\/horn_tactic.cpp":"MODIFY","src\/ast\/rewriter\/rewriter_def.h":"MODIFY"},"diff":{"src\/ast\/ast.cpp":[{"add":["1802","    SASSERT(s_count != 1);","1836","    \/\/    track_id(n, 323);","2904","           tout << p1->get_id() << \": \" << mk_bounded_pp(p1, *this, 5) << \"\\n\\n\";","2905","           tout << p2->get_id() << \": \" << mk_bounded_pp(p2, *this, 5) << \"\\n\\n\";","2915","    proof* p = mk_app(m_basic_family_id, PR_TRANSITIVITY, p1, p2, mk_app(f, to_app(get_fact(p1))->get_arg(0), to_app(get_fact(p2))->get_arg(1)));","2916","","2917","\/\/    SASSERT(p->get_id() != 202);","2918","    return p;","2960","    proof* p = mk_app(m_basic_family_id, PR_MONOTONICITY, args.size(), args.c_ptr());","2961","    SASSERT(p->get_id() != 202);","2962","    return p;"],"delete":["1802","    \/\/SASSERT(s_count != 2);","1836","    \/\/ track_id(n, 48);","2904","           tout << mk_bounded_pp(p1, *this, 5) << \"\\n\\n\";","2905","           tout << mk_bounded_pp(p2, *this, 5) << \"\\n\\n\";","2915","    return mk_app(m_basic_family_id, PR_TRANSITIVITY, p1, p2, mk_app(f, to_app(get_fact(p1))->get_arg(0), to_app(get_fact(p2))->get_arg(1)));","2957","    return mk_app(m_basic_family_id, PR_MONOTONICITY, args.size(), args.c_ptr());"]}],"src\/muz\/base\/hnf.cpp":[{"add":["167","            tout << mk_pp(n, m) << \"\\n==>\\n\" << result << \"\\n\";);","457","    proof_ref mk_congruence(proof* p, expr_ref_vector const& body, expr* head, proof_ref_vector& defs) {","459","            return proof_ref(p, m);","462","            SASSERT(p);","463","            proof_ref p1(p, m), p2(m), p3(m);"],"delete":["167","              tout << mk_pp(n, m) << \"\\n==>\\n\";","168","              for (unsigned i = 0; i < result.size(); ++i) {","169","                  tout << mk_pp(result[i].get(), m) << \"\\n\";","170","              });","460","    proof_ref mk_congruence(proof* p1, expr_ref_vector const& body, expr* head, proof_ref_vector& defs) {","462","            return proof_ref(p1, m);","465","            SASSERT(p1);","466","            proof_ref p2(m), p3(m);"]}],"src\/muz\/fp\/horn_tactic.cpp":[{"add":["351","                not_supported(\"engine=datalog\");","353","                not_supported(\"datalog.generate_explanations\"); ","355","                not_supported(\"datalog.magic_sets_for_queries\");","356","            if (p.xform_instantiate_arrays())","357","                not_supported(\"xform.instantiate_arrays\");","358","            if (p.xform_magic())","359","                not_supported(\"xform.magic\");","362","        void not_supported(char const* s) {","363","            throw default_exception(std::string(\"unsupported parameter \") + s);"],"delete":["351","                not_supported();","353","                not_supported(); ","355","                not_supported();","358","        void not_supported() {","359","            throw default_exception(\"unsupported parameter combination passed to HORN tactic\");"]}],"src\/ast\/rewriter\/rewriter_def.h":[{"add":["186","            TRACE(\"rewriter\", tout << \"process const: \" << mk_bounded_pp(t, m()) << \" -> \" << mk_bounded_pp(m_r,m()) << \"\\n\";);","305","        SASSERT(st == BR_FAILED || rewrites_from(new_t, m_pr2));","318","                SASSERT(rewrites_to(m_r, m_pr));","319","                SASSERT(rewrites_from(t, m_pr));","352","                    SASSERT(rewrites_to(m_r, m_pr));","353","                    SASSERT(rewrites_from(t, m_pr));"],"delete":[]}]}},"b6618892d80355ef219c4c652206dff43833fdc4":{"changes":{"src\/smt\/theory_arith_nl.h":"MODIFY","src\/smt\/theory_arith.h":"MODIFY"},"diff":{"src\/smt\/theory_arith_nl.h":[{"add":["1204","void theory_arith<Ext>::display_coeff_exprs(std::ostream & out, buffer<coeff_expr> const & p) const {","1205","    typename buffer<coeff_expr>::const_iterator it  = p.begin();","1206","    typename buffer<coeff_expr>::const_iterator end = p.end();","1222","bool theory_arith<Ext>::get_polynomial_info(buffer<coeff_expr> const & p, sbuffer<var_num_occs> & varinfo) {","1264","expr * theory_arith<Ext>::p2expr(buffer<coeff_expr> & p) {","1310","bool theory_arith<Ext>::in_monovariate_monomials(buffer<coeff_expr> & p, expr * var,","1330","    typename buffer<coeff_expr>::const_iterator it  = p.begin();","1331","    typename buffer<coeff_expr>::const_iterator end = p.end();","1420","unsigned theory_arith<Ext>::get_min_degree(buffer<coeff_expr> & p, expr * var) {","1425","    buffer<coeff_expr>::const_iterator it  = p.begin();","1426","    buffer<coeff_expr>::const_iterator end = p.end();","1477","expr * theory_arith<Ext>::horner(unsigned depth, buffer<coeff_expr> & p, expr * var) {","1485","    buffer<coeff_expr> e; \/\/ monomials\/x^d where var occurs with degree d","1486","    buffer<coeff_expr> r; \/\/ rest","1523"," expr * theory_arith<Ext>::cross_nested(unsigned depth, buffer<coeff_expr> & p, expr * var) {","1590","                buffer<coeff_expr> rest;","1614","bool theory_arith<Ext>::is_cross_nested_consistent(buffer<coeff_expr> & p) {","1708","    buffer<coeff_expr> p;"],"delete":["1204","void theory_arith<Ext>::display_coeff_exprs(std::ostream & out, sbuffer<coeff_expr> const & p) const {","1205","    typename sbuffer<coeff_expr>::const_iterator it  = p.begin();","1206","    typename sbuffer<coeff_expr>::const_iterator end = p.end();","1222","bool theory_arith<Ext>::get_polynomial_info(sbuffer<coeff_expr> const & p, sbuffer<var_num_occs> & varinfo) {","1264","expr * theory_arith<Ext>::p2expr(sbuffer<coeff_expr> & p) {","1310","bool theory_arith<Ext>::in_monovariate_monomials(sbuffer<coeff_expr> & p, expr * var,","1330","    typename sbuffer<coeff_expr>::const_iterator it  = p.begin();","1331","    typename sbuffer<coeff_expr>::const_iterator end = p.end();","1420","unsigned theory_arith<Ext>::get_min_degree(sbuffer<coeff_expr> & p, expr * var) {","1425","    sbuffer<coeff_expr>::const_iterator it  = p.begin();","1426","    sbuffer<coeff_expr>::const_iterator end = p.end();","1477","expr * theory_arith<Ext>::horner(unsigned depth, sbuffer<coeff_expr> & p, expr * var) {","1485","    sbuffer<coeff_expr> e; \/\/ monomials\/x^d where var occurs with degree d","1486","    sbuffer<coeff_expr> r; \/\/ rest","1523"," expr * theory_arith<Ext>::cross_nested(unsigned depth, sbuffer<coeff_expr> & p, expr * var) {","1590","                sbuffer<coeff_expr> rest;","1614","bool theory_arith<Ext>::is_cross_nested_consistent(sbuffer<coeff_expr> & p) {","1708","    sbuffer<coeff_expr> p;"]}],"src\/smt\/theory_arith.h":[{"add":["1002","        bool get_polynomial_info(buffer<coeff_expr> const & p, sbuffer<var_num_occs> & vars);","1003","        expr * p2expr(buffer<coeff_expr> & p);","1010","        unsigned get_min_degree(buffer<coeff_expr> & p, expr * var);","1012","        bool in_monovariate_monomials(buffer<coeff_expr> & p, expr * var, unsigned & i1, rational & c1, unsigned & n1, unsigned & i2, rational & c2, unsigned & n2);","1013","        expr * horner(unsigned depth, buffer<coeff_expr> & p, expr * var);","1014","        expr * cross_nested(unsigned depth, buffer<coeff_expr> & p, expr * var);","1015","        bool is_cross_nested_consistent(buffer<coeff_expr> & p);","1151","        void display_coeff_exprs(std::ostream & out, buffer<coeff_expr> const & p) const;"],"delete":["1002","        bool get_polynomial_info(sbuffer<coeff_expr> const & p, sbuffer<var_num_occs> & vars);","1003","        expr * p2expr(sbuffer<coeff_expr> & p);","1010","        unsigned get_min_degree(sbuffer<coeff_expr> & p, expr * var);","1012","        bool in_monovariate_monomials(sbuffer<coeff_expr> & p, expr * var, unsigned & i1, rational & c1, unsigned & n1, unsigned & i2, rational & c2, unsigned & n2);","1013","        expr * horner(unsigned depth, sbuffer<coeff_expr> & p, expr * var);","1014","        expr * cross_nested(unsigned depth, sbuffer<coeff_expr> & p, expr * var);","1015","        bool is_cross_nested_consistent(sbuffer<coeff_expr> & p);","1151","        void display_coeff_exprs(std::ostream & out, sbuffer<coeff_expr> const & p) const;"]}]}},"b5c77065e95cfbf6e667a43079708b852792cc7d":{"changes":{"src\/smt\/theory_str.cpp":"MODIFY"},"diff":{"src\/smt\/theory_str.cpp":[{"add":["8098","            expr_ref emptyStr(mk_string(\"\"), m);"],"delete":["8098","            expr * emptyStr = mk_string(\"\");"]}]}},"43ddb083327fcee316c345a4f9ab7f48e5f18fed":{"changes":{"src\/muz\/rel\/dl_mk_simple_joins.cpp":"MODIFY"},"diff":{"src\/muz\/rel\/dl_mk_simple_joins.cpp":[{"add":["500","                  tout << mk_pp(r->get_head(), m) << \" :-\\n\";","501","                  for (app* a : rule_content) tout << \" \" << mk_pp(a, m) << \"\\n\";);","504","            for (app* t : rule_content)","505","                counter.count_vars(t, +1);","506","            counter.count_vars(r->get_head(), +1);","554","                        SASSERT(non_local_vars.subset_of(rm.collect_vars(new_transf)));","558","                        if (i1 < i2)","559","                            std::swap(i1, i2);","569","                        counter.count_vars(new_lit, -1);"],"delete":["497","                  r->display(m_context, tout << \"rule \");","501","                  for (app* a : rule_content) tout << mk_pp(a, m) << \" \"; tout << \"\\n\";);","504","            counter.count_rule_vars(r, 1);","518","","535","                    var_idx_set transf_vars = rm.collect_vars(new_transf);","553","                        SASSERT(non_local_vars.subset_of(rm.collect_vars(new_transf)));"]}]}},"ef80645a71e2e46190bf631e7f5a345315b132cb":{"changes":{"src\/api\/java\/Context.java":"MODIFY"},"diff":{"src\/api\/java\/Context.java":[{"add":["3811","        synchronized (creation_lock) {","3812","            if (m_refCount.get() == 0 && m_ctx != 0) {","3813","                try {","3814","                    Native.delContext(m_ctx);","3815","                } catch (Z3Exception e) {","3816","                    \/\/ OK?","3817","                    System.out.println(\"Context deletion failed; memory leak possible.\");","3818","                }","3819","                m_ctx = 0;"],"delete":["3811","        if (m_refCount.get() == 0 && m_ctx != 0) {","3812","            try {","3813","                Native.delContext(m_ctx);","3814","            } catch (Z3Exception e) {","3815","                \/\/ OK?","3816","                System.out.println(\"Context deletion failed; memory leak possible.\");","3818","            m_ctx = 0;"]}]}},"1e11b62bc6587579481bb5cfb29170b83f67fa21":{"changes":{"src\/muz\/base\/dl_rule_set.cpp":"MODIFY","src\/muz\/base\/fp_params.pyg":"MODIFY","src\/muz\/spacer\/spacer_util.h":"MODIFY","src\/muz\/base\/dl_rule_set.h":"MODIFY","src\/muz\/transforms\/CMakeLists.txt":"MODIFY","src\/muz\/transforms\/dl_mk_synchronize.h":"ADD","src\/muz\/spacer\/spacer_context.cpp":"MODIFY","src\/muz\/spacer\/spacer_prop_solver.cpp":"MODIFY","src\/muz\/transforms\/dl_mk_synchronize.cpp":"ADD","src\/muz\/spacer\/spacer_context.h":"MODIFY"},"diff":{"src\/muz\/base\/dl_rule_set.cpp":[{"add":["33","            for (auto & kv : o) {","116","                    \/\/ insert d and ensure the invariant","117","                    \/\/ that every predicate is present as","150","        for (func_decl* f : to_remove)","255","    rule_set::rule_set(context & ctx)","256","          : m_context(ctx),","257","            m_rule_manager(ctx.get_rule_manager()),","258","            m_rules(m_rule_manager),","264","    rule_set::rule_set(const rule_set & other)","265","        : m_context(other.m_context),","266","          m_rule_manager(other.m_rule_manager),","355","","358","    }","359","","360","    void rule_set::replace_rule(rule * r, rule * other) {","361","        TRACE(\"dl\", r->display(m_context, tout << \"replace:\"););","362","        func_decl* d = r->get_decl();","363","        rule_vector* rules = m_head2rules.find(d);","364","#define REPLACE_VECTOR(_v)                              \\","365","        for (unsigned i = (_v).size(); i > 0; ) {       \\","366","            --i;                                        \\","367","            if ((_v)[i] == r) {                         \\","368","                (_v)[i] = other;                        \\","369","                break;                                  \\","370","            }                                           \\","371","        }                                               \\","372","","373","        REPLACE_VECTOR(*rules);","374","        REPLACE_VECTOR(m_rules);","375","    }","384","        SASSERT(!is_closed()); \/\/the rule_set is not already closed","445","    const rule_vector & rule_set::get_predicate_rules(func_decl * pred) const {","538","","564","            \/\/the number of the predicate is not stored, therefore it did not appear","565","            \/\/in the algorithm and therefore it does not depend on anything and nothing","660","        \/\/ We put components whose indegree is zero to m_strats and assign its","699","        SASSERT(std::find_if(m_components.begin(), m_components.end(),","732",""],"delete":["33","            for (auto & kv : o) { ","116","                    \/\/ insert d and ensure the invariant ","117","                    \/\/ that every predicate is present as ","150","        for (func_decl* f : to_remove) ","255","    rule_set::rule_set(context & ctx) ","256","          : m_context(ctx), ","257","            m_rule_manager(ctx.get_rule_manager()), ","258","            m_rules(m_rule_manager), ","264","    rule_set::rule_set(const rule_set & other) ","265","        : m_context(other.m_context), ","266","          m_rule_manager(other.m_rule_manager), ","355","        ","358","    }    ","367","        SASSERT(!is_closed()); \/\/the rule_set is not already closed        ","428","    const rule_vector & rule_set::get_predicate_rules(func_decl * pred) const { ","521","            ","547","            \/\/the number of the predicate is not stored, therefore it did not appear ","548","            \/\/in the algorithm and therefore it does not depend on anything and nothing ","643","        \/\/ We put components whose indegree is zero to m_strats and assign its ","682","        SASSERT(std::find_if(m_components.begin(), m_components.end(), ","715","        "]}],"src\/muz\/base\/fp_params.pyg":[{"add":["179","                          ('spacer.use_bg_invs', BOOL, False, 'Enable external background invariants'),"],"delete":[]}],"src\/muz\/spacer\/spacer_util.h":[{"add":["50","        \/\/ XXX: level is 16 bits in class pob","51","        return lvl >= 65535;"],"delete":["50","        return lvl == infty_level ();"]}],"src\/muz\/base\/dl_rule_set.h":[{"add":["79","","133","            : m_deps(deps), m_next_preorder(0)","147","","205","        \/**","206","           \\brief Replace a rule \\c r with the rule \\c other","207","        *\/","208","        void replace_rule(rule * r, rule * other);","282",""],"delete":["79","        ","133","            : m_deps(deps), m_next_preorder(0) ","147","        ","278","    ","282",""]}],"src\/muz\/transforms\/CMakeLists.txt":[{"add":["27","    dl_mk_synchronize.cpp"],"delete":[]}],"src\/muz\/transforms\/dl_mk_synchronize.h":[{"add":[],"delete":[]}],"src\/muz\/spacer\/spacer_context.cpp":[{"add":["495","    m_external(false), m_blocked(false),","496","    m_background(false) {","508","    m_external(false), m_blocked(false),","509","    m_background(false) {","523","    m_external(false), m_blocked(false),","524","    m_background(false) {","925","expr_ref pred_transformer::get_formulas(unsigned level, bool bg) const","928","    m_frames.get_frame_geq_lemmas (level, res, bg);","939","    SASSERT(!lemma->is_background());","980","bool pred_transformer::add_lemma (expr *e, unsigned lvl, bool bg) {","982","    lem->set_background(bg);","1223","void pred_transformer::add_cover(unsigned level, expr* property, bool bg)","1225","    SASSERT(!bg || is_infty_level(level));","1229","    proof_ref pr(m);","1230","    pr = m.mk_asserted(m.mk_true());","1234","        sub.insert(v, c, pr);","1245","        add_lemma(lemmas.get(i), level, bg);","1252","\/\/ compute a conjunction of all background facts","1253","void pred_transformer::get_pred_bg_invs(expr_ref_vector& out) {","1254","    expr_ref inv(m), tmp1(m), tmp2(m);","1255","    ptr_vector<func_decl> preds;","1256","    for (auto kv : m_pt_rules) {","1257","        expr* tag = kv.m_value->tag();","1258","        datalog::rule const &r = kv.m_value->rule();","1259","        find_predecessors (r, preds);","1260","","1261","        for (unsigned i = 0, preds_sz = preds.size(); i < preds_sz; i++) {","1262","            func_decl* pre = preds[i];","1263","            pred_transformer &pt = ctx.get_pred_transformer(pre);","1264","            const lemma_ref_vector &invs = pt.get_bg_invs();","1265","            CTRACE(\"spacer\", !invs.empty(),","1266","                   tout << \"add-bg-invariant: \" << mk_pp (pre, m) << \"\\n\";);","1267","            for (auto inv : invs) {","1268","                \/\/ tag -> inv1 ...  tag -> invn","1269","                tmp1 = m.mk_implies(tag, inv->get_expr());","1270","                pm.formula_n2o(tmp1, tmp2, i);","1271","                out.push_back(tmp2);","1272","                TRACE(\"spacer\", tout << tmp2 << \"\\n\";);","1273","            }","1274","        }","1275","    }","1276","}","1378","    flatten_and(post);","1379","","1380","    \/\/ if equality propagation is disabled in arithmetic, expand","1381","    \/\/ equality literals into two inequalities to increase the space","1382","    \/\/ for interpolation","1383","    if (!ctx.use_eq_prop()) {","1384","        expand_literals(m, post);","1385","    }","1514","    expr_ref_vector cand(m), aux(m), conj(m);","1524","    cand.push_back(mk_not(m, lemma_expr));","1525","    flatten_and (cand);","1536","","1537","    conj.push_back(m_extend_lit);","1538","    if (ctx.use_bg_invs()) get_pred_bg_invs(conj);","1539","","1540","    lbool r = m_solver->check_assumptions (cand, aux, m_transition_clause,","1541","                                           conj.size(), conj.c_ptr(), 1);","1572","    if (ctx.use_bg_invs()) get_pred_bg_invs(conj);","1993","    if (new_lemma->is_background()) {","1994","        SASSERT (is_infty_level(new_lemma->level()));","1995","","1996","        for (auto &l : m_bg_invs) {","1997","            if (l->get_expr() == new_lemma->get_expr()) return false;","1998","        }","1999","        TRACE(\"spacer\", tout << \"add-external-lemma: \"","2000","              << pp_level(new_lemma->level()) << \" \"","2001","              << m_pt.head()->get_name() << \" \"","2002","              << mk_pp(new_lemma->get_expr(), m_pt.get_ast_manager()) << \"\\n\";);","2003","","2004","        m_bg_invs.push_back(new_lemma);","2005","        return true;","2006","    }","2007","","2354","    m_use_bg_invs = m_params.spacer_use_bg_invs();","2483","        IF_VERBOSE(10, verbose_stream() << \"did not find predicate \"","2484","                   << p->get_name() << \"\\n\";);","2489","void context::add_cover(int level, func_decl* p, expr* property, bool bg)","2491","    scoped_proof _pf_(m);","2492","","2497","        IF_VERBOSE(10, verbose_stream() << \"did not find predicate \"","2498","                   << p->get_name() << \"\\n\";);","2501","    pt->add_cover(lvl, property, bg);","2505","{add_cover (infty_level(), p, property, true);}","2507","expr_ref context::get_reachable(func_decl *p) {","2514","bool context::validate() {","2545","        get_level_property(m_inductive_lvl, refs, rs, use_bg_invs());","2686","                                 vector<relation_info>& rs, bool with_bg) const {","2692","        expr_ref conj = r->get_formulas(lvl, with_bg);","2724","                    get_level_property(m_inductive_lvl, refs, rs, use_bg_invs());","2906","    get_level_property(m_inductive_lvl, refs, rs, use_bg_invs());","2939","    get_level_property(m_inductive_lvl, refs, rs, use_bg_invs());"],"delete":["495","    m_external(false), m_blocked(false) {","507","    m_external(false), m_blocked(false) {","521","    m_external(false), m_blocked(false)","522","{","923","expr_ref pred_transformer::get_formulas(unsigned level) const","926","    m_frames.get_frame_geq_lemmas (level, res);","977","bool pred_transformer::add_lemma (expr *e, unsigned lvl) {","1219","void pred_transformer::add_cover(unsigned level, expr* property)","1227","        sub.insert(v, c);","1238","        add_lemma(lemmas.get(i), level);","1474","    expr_ref_vector conj(m), aux(m);","1484","    conj.push_back(mk_not(m, lemma_expr));","1485","    flatten_and (conj);","1496","    expr * bg = m_extend_lit.get ();","1497","    lbool r = m_solver->check_assumptions (conj, aux, m_transition_clause,","1498","                                          1, &bg, 1);","1943","","1944","","2425","        IF_VERBOSE(10, verbose_stream() << \"did not find predicate \" << p->get_name() << \"\\n\";);","2430","void context::add_cover(int level, func_decl* p, expr* property)","2436","        IF_VERBOSE(10, verbose_stream() << \"did not find predicate \" << p->get_name() << \"\\n\";);","2439","    pt->add_cover(lvl, property);","2443","{add_cover (infty_level(), p, property);}","2445","expr_ref context::get_reachable(func_decl *p)","2446","{","2453","bool context::validate()","2454","{","2485","        get_level_property(m_inductive_lvl, refs, rs);","2626","                                 vector<relation_info>& rs) const {","2632","        expr_ref conj = r->get_formulas(lvl);","2664","                    get_level_property(m_inductive_lvl, refs, rs);","2846","    get_level_property(m_inductive_lvl, refs, rs);","2879","    get_level_property(m_inductive_lvl, refs, rs);"]}],"src\/muz\/spacer\/spacer_prop_solver.cpp":[{"add":["96","    if (is_infty_level(lvl)) return;"],"delete":[]}],"src\/muz\/transforms\/dl_mk_synchronize.cpp":[{"add":[],"delete":[]}],"src\/muz\/spacer\/spacer_context.h":[{"add":["130","    unsigned m_external:1;    \/\/ external lemma from another solver","131","    unsigned m_blocked:1;     \/\/ blocked by CTP","132","    unsigned m_background:1;  \/\/ background assumed fact","166","    void set_background(bool v) {m_background = v;}","167","    bool is_background() {return m_background;}","168","","228","        lemma_ref_vector m_bg_invs;        \/\/ background (assumed) invariants","237","        frames (pred_transformer &pt) : m_pt (pt),","238","                                        m_size(0), m_sorted (true) {}","253","        void get_frame_geq_lemmas (unsigned level, expr_ref_vector &out,","254","                                   bool with_bg = false) const {","260","            if (with_bg) {","261","                for (auto &lemma : m_bg_invs)","262","                    out.push_back(lemma->get_expr());","263","            }","266","        const lemma_ref_vector& get_bg_invs() const {return m_bg_invs;}","267","        unsigned size() const {return m_size;}","268","        unsigned lemma_size() const {return m_lemmas.size ();}","269","        unsigned bg_invs_size() const {return m_bg_invs.size();}","270","","271","        void add_frame() {m_size++;}","281","            m_bg_invs.append(other.m_bg_invs);","435","    \/\/ get tagged formulae of all of the background invariants for all of the","436","    \/\/ predecessors of the current transformer","437","    void get_pred_bg_invs(expr_ref_vector &out);","438","    const lemma_ref_vector &get_bg_invs() const {return m_frames.get_bg_invs();}","439","","470","    void     add_cover(unsigned level, expr* property, bool bg = false);","506","    bool add_lemma(expr * e, unsigned lvl, bool bg);","549","    expr_ref get_formulas(unsigned level, bool bg = false) const;","980","    bool                 m_use_bg_invs;","1015","                            vector<relation_info> & rs,","1016","                            bool with_bg = false) const;","1051","    bool use_eq_prop() const {return m_use_eq_prop;}","1052","    bool use_native_mbp() const {return m_use_native_mbp;}","1053","    bool use_ground_pob() const {return m_ground_pob;}","1054","    bool use_instantiate() const {return m_instantiate;}","1055","    bool weak_abs() const {return m_weak_abs;}","1056","    bool use_qlemmas() const {return m_use_qlemmas;}","1057","    bool use_euf_gen() const {return m_use_euf_gen;}","1058","    bool simplify_pob() const {return m_simplify_pob;}","1059","    bool use_ctp() const {return m_use_ctp;}","1060","    bool use_inc_clause() const {return m_use_inc_clause;}","1061","    unsigned blast_term_ite_inflation() const {return m_blast_term_ite_inflation;}","1062","    bool elim_aux() const {return m_elim_aux;}","1063","    bool reach_dnf() const {return m_reach_dnf;}","1064","    bool use_bg_invs() const {return m_use_bg_invs;}","1107","    void add_cover(int level, func_decl* pred, expr* property, bool bg = false);"],"delete":["130","    unsigned m_external:1;","131","    unsigned m_blocked:1;","232","        frames (pred_transformer &pt) : m_pt (pt), m_size(0), m_sorted (true) {}","247","        void get_frame_geq_lemmas (unsigned level, expr_ref_vector &out) const {","255","        unsigned size () const {return m_size;}","256","        unsigned lemma_size () const {return m_lemmas.size ();}","257","        void add_frame () {m_size++;}","450","    void     add_cover(unsigned level, expr* property);","486","    bool add_lemma(expr * lemma, unsigned lvl);","529","    expr_ref get_formulas(unsigned level) const;","994","                            vector<relation_info> & rs) const;","1029","    bool use_native_mbp () {return m_use_native_mbp;}","1030","    bool use_ground_pob () {return m_ground_pob;}","1031","    bool use_instantiate () {return m_instantiate;}","1032","    bool weak_abs() {return m_weak_abs;}","1033","    bool use_qlemmas () {return m_use_qlemmas;}","1034","    bool use_euf_gen() {return m_use_euf_gen;}","1035","    bool simplify_pob() {return m_simplify_pob;}","1036","    bool use_ctp() {return m_use_ctp;}","1037","    bool use_inc_clause() {return m_use_inc_clause;}","1038","    unsigned blast_term_ite_inflation() {return m_blast_term_ite_inflation;}","1039","    bool elim_aux() {return m_elim_aux;}","1040","    bool reach_dnf() {return m_reach_dnf;}","1083","    void add_cover(int level, func_decl* pred, expr* property);"]}]}},"d00d6a3506d57a2a58d3a62e9e915ce05697f676":{"changes":{"src\/smt\/smt_conflict_resolution.cpp":"MODIFY","src\/smt\/smt_setup.cpp":"MODIFY"},"diff":{"src\/smt\/smt_conflict_resolution.cpp":[{"add":["117","            CTRACE(\"dyn_ack_target\", !lhs->is_eq(), tout << \"dyn_ack_target2: \" << lhs->get_owner_id() << \" \" << rhs->get_owner_id() << \"\\n\";);"],"delete":["117","            if (!lhs->is_eq())","118","                TRACE(\"dyn_ack_target\", tout << \"dyn_ack_target2: \" << lhs->get_owner_id() << \" \" << rhs->get_owner_id() << \"\\n\";);"]}],"src\/smt\/smt_setup.cpp":[{"add":["553","        m_params.m_propagate_booleans  = true;"],"delete":[]}]}},"1e7a9e3e61c3cc2dbb8fea6744ee369ea0dbdc4b":{"changes":{"src\/opt\/opt_cmds.cpp":"MODIFY","src\/cmd_context\/parametric_cmd.h":"MODIFY"},"diff":{"src\/opt\/opt_cmds.cpp":[{"add":["107","        reset_params();"],"delete":[]}],"src\/cmd_context\/parametric_cmd.h":[{"add":["36","    void reset_params() { m_params.reset(); }"],"delete":[]}]}}}